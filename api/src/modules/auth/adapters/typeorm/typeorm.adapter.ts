import { createAdapterFactory } from 'better-auth/adapters';
import type { Where } from 'better-auth/types';
import {
  DataSource,
  EntityTarget,
  FindOptionsOrder,
  FindOptionsSelect,
  ObjectLiteral,
  Repository,
} from 'typeorm';
import { getEntityClass } from './entity-mapper';
import { DatabaseOperationError, RecordNotFoundError } from './errors';
import { convertToTypeORMWhere, normalizeWhereClause } from './query-translator';
import type { SchemaConfig, TypeORMAdapterConfig } from './types';

/**
 * Create TypeORM adapter factory for better-auth
 *
 * @param dataSource - TypeORM DataSource instance
 * @param config - Adapter configuration
 * @returns Better-Auth adapter factory
 */
export function typeormAdapter(dataSource: DataSource, config: TypeORMAdapterConfig = {}) {
  return createAdapterFactory({
    config: {
      adapterId: 'typeorm',
      adapterName: 'TypeORM Adapter',
      usePlural: config.usePlural ?? false,
      debugLogs: config.debugLogs ?? false,
      supportsJSON: config.provider !== 'oracle',
      supportsDates: true,
      supportsBooleans: true,
      supportsNumericIds: true,
    },

    // Adapter factory function
    adapter: (adapterOptions) => {
      const {
        options: _options,
        schema: _betterAuthSchema,
        debugLog,
        getFieldName: _getFieldName,
        getModelName: _getModelName,
      } = adapterOptions;

      const customSchema: SchemaConfig = config.schema ?? {};

      function getRepository(model: string): Repository<ObjectLiteral> {
        const entityClass: EntityTarget<ObjectLiteral> = getEntityClass(model, customSchema);
        return dataSource.getRepository(entityClass);
      }

      function selectFields<T extends Record<string, unknown>>(result: T, select?: string[]): T {
        if (!select || select.length === 0) {
          return result;
        }

        const filtered: Record<string, unknown> = {};
        for (const field of select) {
          if (field in result) {
            filtered[field] = result[field];
          }
        }
        return filtered as T;
      }

      return {
        id: 'typeorm',

        create: async <T extends Record<string, unknown>, R = T>(params: {
          model: string;
          data: Omit<T, 'id'>;
          select?: string[];
        }): Promise<R> => {
          const { model, data, select } = params;
          if (debugLog) {
            debugLog({ operation: 'create', model, data, select });
          }

          try {
            const repository = getRepository(model);
            // Remove 'id' from data if present, as entities with @Generated('uuid') 
            // should have their IDs generated by the database
            const { id, ...dataWithoutId } = data as Record<string, unknown>;
            const entity = repository.create(dataWithoutId);
            const savedEntity = await repository.save<Record<string, unknown>>(entity);

            return selectFields(savedEntity, select) as R;
          } catch (error) {
            if (error instanceof Error) {
              throw new DatabaseOperationError('create', model, error);
            }
            throw error;
          }
        },

        findOne: async <T>(params: {
          model: string;
          where: Where[];
          select?: string[];
        }): Promise<T | null> => {
          const { model, where, select } = params;
          if (debugLog) {
            debugLog({ operation: 'findOne', model, where, select });
          }

          const repository = getRepository(model);
          const normalizedWhere = normalizeWhereClause(where);

          const typeormWhere = convertToTypeORMWhere(normalizedWhere);

          const selectOptions: FindOptionsSelect<ObjectLiteral> | undefined = select
            ? (select.reduce(
                (acc, field) => ({ ...acc, [field]: true }),
                {} as Record<string, boolean>,
              ) as FindOptionsSelect<ObjectLiteral>)
            : undefined;

          const result = await repository.findOne({
            where: typeormWhere,
            select: selectOptions,
          });

          if (!result) {
            return null;
          }

          return result as T;
        },

        findMany: async <T>(params: {
          model: string;
          where?: Where[];
          limit?: number;
          offset?: number;
          sortBy?: { field: string; direction: 'asc' | 'desc' };
          select?: string[];
        }): Promise<T[]> => {
          const { model, where, limit, offset, sortBy, select } = params;
          if (debugLog) {
            debugLog({ operation: 'findMany', model, where, limit, offset, sortBy });
          }

          const repository = getRepository(model);
          const normalizedWhere = where ? normalizeWhereClause(where) : undefined;

          const typeormWhere = normalizedWhere ? convertToTypeORMWhere(normalizedWhere) : undefined;

          const selectOptions: FindOptionsSelect<ObjectLiteral> | undefined = select
            ? (select.reduce(
                (acc, field) => ({ ...acc, [field]: true }),
                {} as Record<string, boolean>,
              ) as FindOptionsSelect<ObjectLiteral>)
            : undefined;

          const orderOptions: FindOptionsOrder<ObjectLiteral> | undefined = sortBy
            ? ({
                [sortBy.field]: sortBy.direction.toUpperCase(),
              } as FindOptionsOrder<ObjectLiteral>)
            : undefined;

          const results = await repository.find({
            where: typeormWhere,
            take: limit,
            skip: offset,
            order: orderOptions,
            select: selectOptions,
          });

          return results as T[];
        },

        count: async (params: { model: string; where?: Where[] }): Promise<number> => {
          const { model, where } = params;
          if (debugLog) {
            debugLog({ operation: 'count', model, where });
          }

          const repository = getRepository(model);
          const normalizedWhere = where ? normalizeWhereClause(where) : undefined;

          const typeormWhere = normalizedWhere ? convertToTypeORMWhere(normalizedWhere) : undefined;

          return await repository.count({
            where: typeormWhere,
          });
        },

        update: async <T>(params: {
          model: string;
          where: Where[];
          update: T;
        }): Promise<T | null> => {
          const { model, where, update } = params;
          if (debugLog) {
            debugLog({ operation: 'update', model, where, update });
          }

          try {
            const repository = getRepository(model);
            const normalizedWhere = normalizeWhereClause(where);
            const typeormWhere = convertToTypeORMWhere(normalizedWhere);

            const entity = await repository.findOne({
              where: typeormWhere,
            });

            if (!entity) {
              throw new RecordNotFoundError(model, normalizedWhere);
            }

            Object.assign(entity, update);
            const savedEntity = await repository.save(entity);

            return savedEntity as T;
          } catch (error) {
            if (error instanceof RecordNotFoundError) {
              throw error;
            }
            if (error instanceof Error) {
              throw new DatabaseOperationError('update', model, error);
            }
            throw error;
          }
        },

        updateMany: async (params: {
          model: string;
          where: Where[];
          update: Record<string, unknown>;
        }): Promise<number> => {
          const { model, where, update } = params;
          if (debugLog) {
            debugLog({ operation: 'updateMany', model, where, update });
          }

          const repository = getRepository(model);
          const normalizedWhere = normalizeWhereClause(where);

          const typeormWhere = convertToTypeORMWhere(normalizedWhere);

          const result = await repository.update(typeormWhere, update);
          return result.affected ?? 0;
        },

        delete: async (params: { model: string; where: Where[] }): Promise<void> => {
          const { model, where } = params;
          if (debugLog) {
            debugLog({ operation: 'delete', model, where });
          }

          const repository = getRepository(model);
          const normalizedWhere = normalizeWhereClause(where);

          const typeormWhere = convertToTypeORMWhere(normalizedWhere);

          await repository.delete(typeormWhere);
        },

        deleteMany: async (params: { model: string; where: Where[] }): Promise<number> => {
          const { model, where } = params;
          if (debugLog) {
            debugLog({ operation: 'deleteMany', model, where });
          }

          const repository = getRepository(model);
          const normalizedWhere = normalizeWhereClause(where);

          const typeormWhere = convertToTypeORMWhere(normalizedWhere);

          const result = await repository.delete(typeormWhere);
          return result.affected ?? 0;
        },
      };
    },
  });
}
